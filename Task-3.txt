Описание/Пошаговая инструкция выполнения домашнего задания:

На примере реализации игры «Угадай число» продемонстрировать практическое применение SOLID принципов.
Программа рандомно генерирует число, пользователь должен угадать это число. 
При каждом вводе числа программа пишет больше или меньше отгадываемого. 
Кол-во попыток отгадывания и диапазон чисел должен задаваться из настроек.
В отчёте написать, что именно сделано по каждому принципу.
Приложить ссылку на проект и написать, сколько времени ушло на выполнение задачи.


Критерии оценки:
1. 2 балла: Принцип единственной ответственности;
2. 1 балла: Принцип инверсии зависимостей;
3. 2 балла: Принцип разделения интерфейса;
4. 2 балла: Принцип открытости/закрытости;
5. 2 балла: Принцип подстановки Барбары Лисков;
1 балл: CodeStyle, грамотная архитектура, всё замечания проверяющего исправлены.
Минимально необходимый балл: 6.


1. Принцип единственной ответственности

Каждый класс содержит методы принадлежащиие только одной обязанности. 
(нет такого, что метод допустим сохраняет инфу и отправляет кому-то уведомление)

2. Принцип инверсии зависимостей

Высокоуровневые модули не должны зависеть от низкоуровневых модулей. 
Оба типа модулей должны зависеть от абстракций. 

ConfigService зависит от абстракции IConfigurationRoot, но не от ее конкретной реализации.
Таким образом, мы можем подменить IConfigurationRoot, не меняя код в ConfigService.
При этом получим правильную работу программы.

3. Принцип разделения интерфейса

Класс не должен зависеть от методов, которые не использует.
Соответственно, если мы считаем, что каждый метод - каждое действие, определяется одним интерфейсом. 
То наш класс должен напрямую зависеть только от этих действий, соответсвенно от этих интверфейсов.

Например, в данном проекте, класс GuessGameService зависит от IGuessGame и метода TryGuess.

4. Принцип открытости/закрытости

Классы должны быть открыты для расширения, но закрыты для модификации.
Напрмиер, в данном проекте существует класс GameStarterService, в котором есть метод 

        public void StartGame(IGame game)
        {
            game.Start();
        }

Существуют интерфейсы IGame, IGuessGame и класс GuessGameService.
Мы можем их менять, при этом не изменяя код исходного класса GameStarterService.

5. Принцип подстановки Барбары Лисков

Используя описанные ранее интерфейсы, мы можем создать новую игру, новый класс.
Далее запустить ее с помощью класса GameStarterService.
Объекты могут быть заменяемы их подтипами, при этом программа будет отрабатывать корректно.