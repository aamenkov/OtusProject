# Репозиторий для работы с заданиями курса Otus "C# Developer. Professional"


## Задание 1:
1. Создать базу данных PostgreSQL для одной из компаний на выбор: Авито, СберБанк, Otus или eBay. 
Написать скрипт создания 3 таблиц, которые должны иметь первичные ключи и быть соединены внешними ключами.
2. Написать скрипт заполнения таблиц данными, минимум по пять строк в каждую.
3. Создать консольную программу, которая выводит содержимое всех таблиц.
4. Добавить в программу возможность добавления в таблицу на выбор.

### Что было сделано?

Набор проектов находится в папке решения "Task-1", содержит в себе три проекта.
- DbConsole (исполняющий консоль-проект, содержит логику получения данных от пользователя с помощью консоли)
- DbConsole.Application (основная логика, модели приложения, конвертеры, сервисы инициализации и работы с БД)
- DbConsole.Infrastructure (контекст и сущности БД, скрпит для второго задания)

В проекте DbConsole содержится файл appsettings.json, в который необходимо добавить строку подключения к БД.

---

## Задание 2:
1. Создать эндпоинты в проекте WebApi (https://gitlab.com/otus-education/dotnetdev.homework.7)
2. Доработать консольное приложение, чтобы оно удовлетворяло следующим требованиям:
3. Принимает с консоли ID "Клиента", запрашивает его с сервера и отображает его данные по пользователю;
4. Генерирует случайным образом данные для создания нового "Клиента" на сервере;
5. Отправляет данные, созданные в пункте 2.2., на сервер;
6. По полученному ID от сервера запросить созданного пользователя с сервера и вывести на экран.

### Что было сделано?

Набор проектов находится в папке решения "Task-2", содержит в себе два проекта.
- Customer.WebApi (сервис, содержащий в себе endpoint и реализующий crud-методы для работы с покупателям)
- Customer.Console (исполняющий консоль-проект, содержит в себе клиент и простую логику работы с rest-сервисом)

Перед тем как работать с проектом, необходимо прописать строку подключения к БД в launch profile - 'ConnectionStringPostgres'
Создать БД можно с помощью 'Add-Megration {name}', опубликовать с помощью {update-database} в package manager condole

---

## Задание 3:
1. На примере реализации игры «Угадай число» продемонстрировать практическое применение SOLID принципов.
2. Программа рандомно генерирует число, пользователь должен угадать это число. 
3. При каждом вводе числа программа пишет больше или меньше отгадываемого. 
4. Кол-во попыток отгадывания и диапазон чисел должен задаваться из настроек.

### Что было сделано?

Проект находится в папке решения "Task-3"
- GuessGame.Console (исполняющий консоль-проект, содержит в себе логику игры)

В сопровождающем файле Task-3.txt, вся информация о принципах SOLID и как они были реализованы в этом проекте.

---

## Задание 4:
1. Написать сериализацию свойств или полей класса в строку
2. Проверить на классе: class F { int i1, i2, i3, i4, i5; Get() => new F(){ i1 = 1, i2 = 2, i3 = 3, i4 = 4, i5 = 5 }; }
3. Замерить время до и после вызова функции (для большей точности можно сериализацию сделать в цикле 100-100000 раз)
4. Вывести в консоль полученную строку и разницу времен
5. Отправить в чат полученное время с указанием среды разработки и количества итераций
6. Замерить время еще раз и вывести в консоль сколько потребовалось времени на вывод текста в консоль
7. Провести сериализацию с помощью каких-нибудь стандартных механизмов (например в JSON)
8. И тоже посчитать время и прислать результат сравнения
9. Написать десериализацию/загрузку данных из строки (ini/csv-файла) в экземпляр любого класса
10. Замерить время на десериализацию
11. Общий результат прислать в чат с преподавателем в системе.

### Что было сделано?

Мой результат.
Сериализуемый класс: class F { int i1, i2, i3, i4, i5;}
Elapsed Time (amount = 100000)

For Custom Serialization: 00:00:00.0142395
For JSON Serialization: 00:00:00.2801615
For Custom Deserialization: 00:00:00.0945525
For JSON Deserialization: 00:00:00.2000148

For CSV Custom Serialization: 00:00:00.0005116
For CSV Custom Deserialization: 00:00:00.0003591
Name: John, Age: 30

Проект находится в папке решения "Task-4"
- Reflection.Console (исполняющий консоль-проект)

Созданы методы, которые осуществляют подсчет времени сериализации и десериализации, с помощью стандартных библиотек и кастомных способов.

---

## Задание 5:
1. Написать обобщённую функцию расширения, находящую и возвращающую максимальный элемент коллекции.
Функция должна принимать на вход делегат, преобразующий входной тип в число для возможности поиска максимального значения.
public static T GetMax(this IEnumerable collection, Func<T, float> convertToNumber) where T : class;
2. Написать класс, обходящий каталог файлов и выдающий событие при нахождении каждого файла;
3. Оформить событие и его аргументы с использованием .NET соглашений:
public event EventHandler FileFound;
FileArgs – будет содержать имя файла и наследоваться от EventArgs
4. Добавить возможность отмены дальнейшего поиска из обработчика;
5. Вывести в консоль сообщения, возникающие при срабатывании событий и результат поиска максимального элемента

### Что было сделано?

Проект находится в папке решения "Task-5"
- DelegateAndEvents.Console (исполняющий консоль-проект)

Консольное приложение вызывает расширенную функцию, для получения результата.
Затем, подписывается на событие "Файл найден" и "Поиск отменен".
Далее, начинает осуществлять поиск до его отмены. О чем и гласит появившееся сообщение.

---

## Задание 6:
1. Прочитать 3 файла параллельно и вычислить количество пробелов в них (через Task).
2. Написать функцию, принимающую в качестве аргумента путь к папке. Из этой папки параллельно прочитать все файлы и вычислить количество пробелов в них.
Замерьте время выполнения кода (класс Stopwatch).

### Что было сделано?

Проект находится в папке решения "Task-6"
- TaskFileReader.Console (исполняющий консоль-проект)

Консоль содержит два метода, которые могут быть использованы для подсчета пробелов в директории.

Каждый метод содержит класс Stopwatch, для подсчета времени.

- 1 метод - Способ с массивом из Task
- 2 метод - Способ с ParalelForEach
Опытным путем было выявлено, что второй метод - работает быстрее.

---

## Задание 7:
1. Напишите вычисление суммы элементов массива интов:
	- Обычное
	- Параллельное (для реализации использовать Thread, например List)
	- Параллельное с помощью LINQ
2. Замерьте время выполнения для 100 000, 1 000 000 и 10 000 000
3. Укажите в таблице результаты замеров, указав:
	- Окружение (характеристики компьютера и ОС)
	- Время выполнения последовательного вычисления
	- Время выполнения параллельного вычисления
	- Время выполнения LINQ

### Что было сделано?

Проект находится в папке решения "Task-7"
- ParalelComputing.Console (исполняющий консоль-проект)

Производится запуск с разным размером массива программы, для проверки работоспособности с раными размерами массива. 

Характеристики компьютера:
- Операционная система: Microsoft Windows NT 10.0.19045.0
- Процессор: 12 ядер
- Общий объем памяти: 16777216 байт

Размер данных | Метод вычисления | Время выполнения
------------- | ---------------- | -----------------
100 000 | Обычное вычисление | 1 мс
100 000 | Параллельное вычисление с помощью Thread | 54 мс
100 000 | Параллельное вычисление с помощью ParalellForEach | 79 мс
100 000 | Параллельное вычисление с помощью LINQ | 30 мс
------------- | ---------------- | -----------------
1000 000 | Обычное вычисление | 5 мс
1000 000 | Параллельное вычисление с помощью Thread | 67 мс
1000 000 | Параллельное вычисление с помощью ParalellForEach | 0 мс
1000 000 | Параллельное вычисление с помощью LINQ | 2 мс
------------- | ---------------- | -----------------
10 000 000 | Обычное вычисление | 58 мс
10 000 000 | Параллельное вычисление с помощью Thread | 63 мс
10 000 000 | Параллельное вычисление с помощью ParalellForEach | 4 мс
10 000 000 | Параллельное вычисление с помощью LINQ | 15 мс

---

## Задание 8:
1. Придумать и создать 3-4 класса, которые как минимум дважды наследуются и написать краткое описание текстом.
2. Создать свой дженерик интерфейс IMyCloneable для реализации шаблона "Прототип".
3. Сделать возможность клонирования объекта для каждого из этих классов, используя вызовы родительских конструкторов.
4. Составить тесты или написать программу для демонстрации функции клонирования.
5. Добавить к каждому классу реализацию стандартного интерфейса ICloneable и реализовать его функционал через уже созданные методы.
6. Написать вывод: какие преимущества и недостатки у каждого из интерфейсов: IMyCloneable и ICloneable.

### Что было сделано?

Проект находится в папке решения "Task-8"
- PrototypePattern.Console (исполняющий консоль-проект)

Производится запуск программы и клонирование объекта через метод Clone(), реализованным с помощью интерфейса ICloneable, а так же клонирование через метод MyClone() реализованного интерфейса IMyCloneable

Вывод:

Преимущества IMyCloneable:
- Явное указание того, что класс поддерживает клонирование.
- Возможность типобезопасного клонирования.
- Возможность определить свою логику клонирования, что может быть полезно в специфических случаях.

Недостатки IMyCloneable:
- Требует реализации метода MyClone в каждом классе, что может привести к дублированию кода.

Преимущества ICloneable:
- Встроенный интерфейс в .NET, что упрощает его использование.
- Простота использования, т.к. классы, реализующие этот интерфейс, могут воспользоваться стандартными методами клонирования.

Недостатки ICloneable:
- Неявное использование интерфейса, что может привести к проблемам с типобезопасностью.
- Ограниченная гибкость, так как не позволяет явно указать, что только определенные классы поддерживают клонирование.
- Отсутствие возможности предоставить специфическую логику клонирования, 
	т.к. метод Clone() не имеет параметров и не определяет конкретную реализацию.

---
